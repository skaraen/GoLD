parser grammar GoliteParser; 

options {
    tokenVocab = GoliteLexer;
}

program         : types declaration* functions EOF                                                                                      ;       
types           : typeDecl*                                                                                                             ;
typeDecl        : TYPE ID STRUCT LBRACE fields RBRACE SEMICOLON                                                                         ;
fields          : fieldsPrime (fieldsPrime)*                                                                                            ;
fieldsPrime     : decl SEMICOLON                                                                                                        ;
decl            : ID type                                                                                                               ;
type            : INT | BOOL | ASTERIX ID                                                                                               ;
declarations    : declaration*                                                                                                          ;
declaration     : VAR ids type SEMICOLON                                                                                                ;
ids             : ID idsPrime*                                                                                                          ;
idsPrime        : COMMA ID                                                                                                              ;
functions       : (function)*                                                                                                           ;
function        : FUNC ID params returnType? LBRACE declaration* statement*  RBRACE                                                     ;
params          : LPAREN (decl paramsPrime*)? RPAREN                                                                                    ;
paramsPrime     : COMMA decl                                                                                                            ;
returnType      : type                                                                                                                  ;
statements      : stmts = statement*                                                                                                    ;
statement       : assignment | print | read | delete | conditional | loop | return | invocation                                         ;
block           : LBRACE statement*  RBRACE                                                                                             ;
delete          : DELETE expr = expression SEMICOLON                                                                                    ;
read            : SCAN lv = lValue SEMICOLON                                                                                            ;
assignment      : lv = lValue ASSIGN expr = expression SEMICOLON                                                                        ;
print           : PRINTF LPAREN STRING (argsP = argsPrime)* RPAREN SEMICOLON                                                            ;
conditional     : IF LPAREN expr = expression RPAREN if = block (ELSE else = block)?                                                    ;
loop            : FOR LPAREN expr = expression RPAREN bl = block                                                                        ;
return          : RETURN expr = expression SEMICOLON                                                                                    ;
invocation      : ID args SEMICOLON                                                                                                     ;                                                                  
args            : LPAREN (expression argsPrime*)? RPAREN                                                                                ;
argsPrime       : COMMA expr = expression                                                                                               ;
lValue          : ID lValuePrime*                                                                                                       ;
lValuePrime     : DOT ID                                                                                                                ;
expression      : boolTerm exprPrime*                                                                                                   ;
exprPrime       : OR bt = boolTerm                                                                                                      ;
boolTerm        : equalTerm boolTermPrime*                                                                                              ;
boolTermPrime   : AND et = equalTerm                                                                                                    ;
equalTermPrime  : op = (EQUALS | NEQUALS) rt = relTerm                                                                                  ;
equalTerm       : relTerm equalTermPrime*                                                                                               ;
relTermPrime    : op = (GT | LT | GTE | LTE) st = simpleTerm                                                                            ;
relTerm         : simpleTerm relTermPrime*                                                                                              ;
simpleTermPrime : op = (PLUS | MINUS) t = term                                                                                          ;
simpleTerm      : term simpleTermPrime*                                                                                                 ;
termPrime       : op = (ASTERIX | FSLASH) ut = unaryTerm                                                                                ;
term            : unaryTerm termPrime*                                                                                                  ;
unaryTerm       : NOT selectorTerm | MINUS selectorTerm | selectorTerm                                                                  ;
selectorTerm    : factor lValuePrime*                                                                                                   ;
factor          : LPAREN expression RPAREN | ID (args)? | NUM | NEW ID | TRUE | FALSE | NIL                                             ;