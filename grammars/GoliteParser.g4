parser grammar GoliteParser; 

options {
    tokenVocab = GoliteLexer;
}

program         : userTypes declarations functions EOF                                                                                  ;       
userTypes       : typeDecl*                                                                                                             ;
typeDecl        : TYPE ID STRUCT LBRACE fields RBRACE SEMICOLON                                                                         ;
fields          : fieldsPrime (fieldsPrime)*                                                                                            ;
fieldsPrime     : declr = decl SEMICOLON                                                                                                ;
decl            : ID type                                                                                                               ;
reference       : ASTERIX name = ID                                                                                                     ;
type            : integer = INT | boolean = BOOL | pointer = reference                                                                  ;
declarations    : declaration*                                                                                                          ;
declaration     : VAR ids type SEMICOLON                                                                                                ;
ids             : ID idsPrime*                                                                                                          ;
idsPrime        : COMMA id = ID                                                                                                         ;
functions       : function*                                                                                                             ;
function        : FUNC ID params returnType? LBRACE declarations statements  RBRACE                                                     ;
params          : LPAREN (decl paramsPrime*)? RPAREN                                                                                    ;
paramsPrime     : COMMA declr = decl                                                                                                    ;
returnType      : rt = type                                                                                                             ;
statements      : stmts = statement*                                                                                                    ;
statement       : assignment | print | read | delete | conditional | loop | return | invocation                                         ;
block           : LBRACE statements  RBRACE                                                                                             ;
delete          : DELETE expression SEMICOLON                                                                                           ;
read            : SCAN lValue SEMICOLON                                                                                                 ;
assignment      : lValue ASSIGN expression SEMICOLON                                                                                    ;
print           : PRINTF LPAREN STRING argsPrime* RPAREN SEMICOLON                                                                      ;
conditional     : IF LPAREN expression RPAREN block (ELSE block)?                                                                       ;
loop            : FOR LPAREN expression RPAREN block                                                                                    ;
return          : RETURN (expression)? SEMICOLON                                                                                           ;
invocation      : ID args SEMICOLON                                                                                                     ;                                                                  
args            : LPAREN (expression argsPrime*)? RPAREN                                                                                ;
argsPrime       : COMMA expr = expression                                                                                               ;
lValue          : ID lValuePrime*                                                                                                       ;
lValuePrime     : DOT pid = ID                                                                                                          ;
expression      : boolTerm exprPrime*                                                                                                   ;
exprPrime       : OR bt = boolTerm                                                                                                      ;
boolTerm        : equalTerm boolTermPrime*                                                                                              ;
boolTermPrime   : AND et = equalTerm                                                                                                    ;
equalTermPrime  : op = (EQUALS | NEQUALS) rt = relTerm                                                                                  ;
equalTerm       : relTerm equalTermPrime*                                                                                               ;
relTermPrime    : op = (GT | LT | GTE | LTE) st = simpleTerm                                                                            ;
relTerm         : simpleTerm relTermPrime*                                                                                              ;
simpleTermPrime : op = (PLUS | MINUS) t = term                                                                                          ;
simpleTerm      : term simpleTermPrime*                                                                                                 ;
termPrime       : op = (ASTERIX | FSLASH) ut = unaryTerm                                                                                ;
term            : unaryTerm termPrime*                                                                                                  ;
unaryTerm       : NOT selectorTerm | MINUS selectorTerm | selectorTerm                                                                  ;
selectorTerm    : factor lValuePrime*                                                                                                   ;
factor          : LPAREN expression RPAREN | ID (args)? | NUM | NEW ID | TRUE | FALSE | NIL                                             ;